{"version":3,"file":"yett.min.js","sources":["../../src/checks.js","../../src/variables.js","../../src/observer.js","../../src/iframe-observer.js","../../src/monkey.js","../../src/unblock.js"],"sourcesContent":["import { patterns, TYPE_ATTRIBUTE } from './variables'\n\nexport const isOnBlacklist = (src, type) => (\n    src &&\n    (!type || type !== TYPE_ATTRIBUTE) &&\n    (\n        (!patterns.blacklist || patterns.blacklist.some(pattern => pattern.test(src))) &&\n        (!patterns.whitelist || patterns.whitelist.every(pattern => !pattern.test(src)))\n    )\n)\n\nexport const willBeUnblocked = function(script) {\n    const src = script.getAttribute('src')\n    return (\n        patterns.blacklist && patterns.blacklist.every(entry => !entry.test(src)) ||\n        patterns.whitelist && patterns.whitelist.some(entry => entry.test(src))\n    )\n}","export const TYPE_ATTRIBUTE = 'javascript/blocked'\n\nexport const patterns = {\n    blacklist: window.YETT_BLACKLIST,\n    whitelist: window.YETT_WHITELIST\n}\n\n// Backup list containing the original blacklisted script elements\nexport const backupScripts = {\n    blacklisted: []\n}","import { backupScripts, TYPE_ATTRIBUTE } from './variables'\nimport { isOnBlacklist } from './checks'\n\n// Setup a mutation observer to track DOM insertion\nexport const observer = new MutationObserver(mutations => {\n    for (let i = 0; i < mutations.length; i++) {\n        const { addedNodes } = mutations[i];\n        for(let i = 0; i < addedNodes.length; i++) {\n            const node = addedNodes[i]\n            // For each added script tag\n            if(node.nodeType === 1 && node.tagName === 'SCRIPT') {\n                const src = node.src\n                const type = node.type\n                // If the src is inside the blacklist and is not inside the whitelist\n                if(isOnBlacklist(src, type)) {\n                    // We backup the node\n                    backupScripts.blacklisted.push([node, node.type])\n\n                    // Blocks inline script execution in Safari & Chrome\n                    node.type = TYPE_ATTRIBUTE\n\n                    // Firefox has this additional event which prevents scripts from beeing executed\n                    const beforeScriptExecuteListener = function (event) {\n                        // Prevent only marked scripts from executing\n                        if(node.getAttribute('type') === TYPE_ATTRIBUTE)\n                            event.preventDefault()\n                        node.removeEventListener('beforescriptexecute', beforeScriptExecuteListener)\n                    }\n                    node.addEventListener('beforescriptexecute', beforeScriptExecuteListener)\n\n                    // Remove the node from the DOM\n                    node.parentElement && node.parentElement.removeChild(node)\n                }\n            }\n        }\n    }\n})\n\n// Starts the monitoring\nobserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true\n})","// import {isOnBlacklist} from \"./checks\";\n//eslint-disable-next-line\n// import {backupScripts, TYPE_ATTRIBUTE} from \"./variables\";\nconst createdFrames = []\nconst debugGate = window.localStorage.getItem('debugGate');\nconst iframeObserver = new MutationObserver(mutations => {\n    for (let i = 0; i < mutations.length; i++) {\n        const { addedNodes } = mutations[i];\n        for(let i = 0; i < addedNodes.length; i++) {\n            const node = addedNodes[i]\n            // For each added script tag\n            if(node.nodeType === 1 && node.tagName === 'IFRAME') {\n                const src = node.src\n                // If the src is inside the blacklist and is not inside the whitelist\n                if(src && createdFrames.includes(src)) {\n\n                    // Remove the node from the DOM\n                    const allFrames = document.querySelectorAll(\"iframe[src^='https://bid.g.doubleclick.net/xbbe/pixel']\")\n                    let count = 0\n                    allFrames.forEach((node)=>{\n                        if(debugGate) {\n                            console.log('keeping node', node);\n                        }\n                        if(count !== 0) {\n                            if(debugGate) {\n                                console.log('removing duplicate node', node);\n                            }\n                            node.parentElement && node.parentElement.removeChild(node);\n                        }\n                        count++\n                    })\n\n                    return\n                }\n                if(src) {\n                    createdFrames.push(src)\n                }\n            }\n        }\n    }\n})\ndocument.addEventListener('readystatechange', function () {\n    if (document.readyState === 'interactive') {\n        // Starts the monitoring\n        iframeObserver.observe(document.body, {\n            childList: true,\n            subtree: false\n        })\n    }\n});\n","import {TYPE_ATTRIBUTE} from './variables'\nimport { isOnBlacklist } from './checks'\n\nconst createElementBackup = document.createElement\n\nconst originalDescriptors = {\n    src: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src'),\n    type: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'type')\n}\n\n// function debounce(func, wait, immediate) {\n//     var timeout;\n//\n//     return function executedFunction() {\n//         var context = this;\n//         var args = arguments;\n//\n//         var later = function() {\n//             timeout = null;\n//             if (!immediate) func.apply(context, args);\n//         };\n//\n//         var callNow = immediate && !timeout;\n//\n//         clearTimeout(timeout);\n//\n//         timeout = setTimeout(later, wait);\n//\n//         if (callNow) func.apply(context, args);\n//     };\n// }\n//\n//\n// let docFrag\n// let supportsPrefetch\n// try {\n//     var relList = document.createElement('link').relList;\n//     supportsPrefetch = !!(relList && relList.supports && relList.supports('prefetch'));\n// } catch(e) {\n//     supportsPrefetch = false\n// }\n\n\n// if(document.createDocumentFragment) {\n//     docFrag = document.createDocumentFragment();\n// }\n// const runDebounce = debounce((current)=>{\n//     document.head.appendChild(current);\n//     docFrag = document.createDocumentFragment()\n// },supportsPrefetch ? 1000 : 4000)\n\n// const preloadBlockedResource = (src) => {\n//     try {\n//         if (window.PREVENT_PRELOAD) {\n//             if (window.PREVENT_PRELOAD.some(pattern => pattern.test(src))) {\n//                 return null\n//             }\n//         }\n//         var preloadLink = document.createElement(\"link\");\n//         preloadLink.href = src\n//         preloadLink.rel = supportsPrefetch ? \"prefetch\" : \"preload\"\n//         preloadLink.as = \"script\";\n//         if (docFrag) {\n//             docFrag.appendChild(preloadLink);\n//             runDebounce(docFrag)\n//         } else {\n//             document.head.appendChild(preloadLink);\n//         }\n//     } catch (e) {\n//         console.error('Gate: Problem Preloading',e)\n//     }\n// }\n\n\n// Monkey patch the createElement method to prevent dynamic scripts from executing\ndocument.createElement = function(...args) {\n    // If this is not a script tag, bypass\n    if(args[0].toLowerCase() !== 'script')\n        return createElementBackup.bind(document)(...args)\n\n    const scriptElt = createElementBackup.bind(document)(...args)\n\n    // Define getters / setters to ensure that the script type is properly set\n    try {\n        Object.defineProperties(scriptElt, {\n            'src': {\n                get() {\n                    return originalDescriptors.src.get.call(this)\n                },\n                set(value) {\n                    if(isOnBlacklist(value, scriptElt.type)) {\n                        // try {preloadBlockedResource(value)} catch(e) {\n                        //     //cannot preload\n                        // }\n                        originalDescriptors.type.set.call(this, TYPE_ATTRIBUTE)\n                    }\n                    originalDescriptors.src.set.call(this, value)\n                }\n            },\n            'type': {\n                set(value) {\n                    const typeValue = isOnBlacklist(scriptElt.src, scriptElt.type) ? TYPE_ATTRIBUTE : value\n                    originalDescriptors.type.set.call(this, typeValue)\n                }\n            }\n        })\n\n        // Monkey patch the setAttribute function so that the setter is called instead\n        scriptElt.setAttribute = function(name, value) {\n            if(name === 'type' || name === 'src')\n                scriptElt[name] = value\n            else\n                HTMLScriptElement.prototype.setAttribute.call(scriptElt, name, value)\n        }\n    } catch (error) {\n        // eslint-disable-next-line\n        console.warn(\n            'Yett: unable to prevent script execution for script src ', scriptElt.src, '.\\n',\n            'A likely cause would be because you are using a third-party browser extension that monkey patches the \"document.createElement\" function.'\n        )\n    }\n    return scriptElt\n}\n","import {\n  patterns,\n  backupScripts,\n  TYPE_ATTRIBUTE\n} from './variables'\n\nimport {\n  willBeUnblocked\n} from './checks'\n\nimport {\n  observer\n} from './observer'\n\nconst URL_REPLACER_REGEXP = new RegExp('[|\\\\{}()[\\\\]^$+*?.]', 'g')\n\n// Unblocks all (or a selection of) blacklisted scripts.\nexport const unblock = function (...scriptUrlsOrRegexes) {\n  if (scriptUrlsOrRegexes.length < 1) {\n    patterns.blacklist = []\n    patterns.whitelist = []\n  } else {\n    if (patterns.blacklist) {\n      patterns.blacklist = patterns.blacklist.filter(pattern => (\n        scriptUrlsOrRegexes.every(urlOrRegexp => {\n          if (typeof urlOrRegexp === 'string')\n            return !pattern.test(urlOrRegexp)\n          else if (urlOrRegexp instanceof RegExp)\n            return pattern.toString() !== urlOrRegexp.toString()\n        })\n      ))\n    }\n    if (patterns.whitelist) {\n      patterns.whitelist = [\n        ...patterns.whitelist,\n        ...scriptUrlsOrRegexes\n          .map(urlOrRegexp => {\n            if (typeof urlOrRegexp === 'string') {\n              const escapedUrl = urlOrRegexp.replace(URL_REPLACER_REGEXP, '\\\\$&')\n              const permissiveRegexp = '.*' + escapedUrl + '.*'\n              if (patterns.whitelist.every(p => p.toString() !== permissiveRegexp.toString())) {\n                return new RegExp(permissiveRegexp)\n              }\n            } else if (urlOrRegexp instanceof RegExp) {\n              if (patterns.whitelist.every(p => p.toString() !== urlOrRegexp.toString())) {\n                return urlOrRegexp\n              }\n            }\n            return null\n          })\n          .filter(Boolean)\n      ]\n    }\n  }\n\n  const ric = window.requestIdleCallback || (cb => setTimeout(cb, 100));\n  // Parse existing script tags with a marked type\n  const tags = document.querySelectorAll(`script[type=\"${TYPE_ATTRIBUTE}\"]`)\n  for (let i = 0; i < tags.length; i++) {\n    const script = tags[i]\n    if (willBeUnblocked(script)) {\n      backupScripts.blacklisted.push([script, 'application/javascript'])\n      script.parentElement.removeChild(script)\n    }\n  }\n\n  const lazyUnblock = (array, callback) => {\n    const reduceRight = array.reduceRight(\n      // eslint-disable-next-line no-unused-vars\n      (prev, current, index) => () => new Promise(resolve => ric(() => {\n        callback(current)\n        resolve(prev());\n      })),\n      () => null,\n    );\n    reduceRight()\n  }\n\n  // Exclude 'whitelisted' scripts from the blacklist and append them to <head>\n  let indexOffset = 0;\n\n  if (window.Promise) {\n    lazyUnblock([...backupScripts.blacklisted], function ([script, type], index) {\n      if (willBeUnblocked(script)) {\n        const scriptNode = document.createElement('script')\n        for(let attr of script.attributes) {\n          scriptNode.setAttribute(attr.name, attr.value);\n        }\n        scriptNode.setAttribute('src', script.src)\n        scriptNode.setAttribute('type', type || 'application/javascript')\n        for (let key in script) {\n          if (key.startsWith(\"on\")) {\n            scriptNode[key] = script[key]\n          }\n        }\n        document.head.appendChild(scriptNode)\n        backupScripts.blacklisted.splice(index - indexOffset, 1)\n        indexOffset++\n      }\n    })\n  } else {\n    [...backupScripts.blacklisted].forEach(([script, type], index) => {\n      const unblockScripts = ([script, type], index) => {\n        if (willBeUnblocked(script)) {\n          const scriptNode = document.createElement('script')\n          for(let attr of script.attributes) {\n            scriptNode.setAttribute(attr.name, attr.value);\n          }\n          scriptNode.setAttribute('src', script.src)\n          scriptNode.setAttribute('type', type || 'application/javascript')\n          for (let key in script) {\n            if (key.startsWith(\"on\")) {\n              scriptNode[key] = script[key]\n            }\n          }\n          document.head.appendChild(scriptNode)\n          backupScripts.blacklisted.splice(index - indexOffset, 1)\n          indexOffset++\n        }\n      }\n\n      ric(() => {\n        unblockScripts([script, type], index)\n      })\n    })\n  }\n\n  // Disconnect the observer if the blacklist is empty for performance reasons\n  if (patterns.blacklist && patterns.blacklist.length < 1) {\n    observer.disconnect()\n  }\n}\n"],"names":["isOnBlacklist","src","type","TYPE_ATTRIBUTE","patterns","blacklist","some","pattern","test","whitelist","every","willBeUnblocked","script","getAttribute","entry","window","YETT_BLACKLIST","YETT_WHITELIST","backupScripts","blacklisted","observer","MutationObserver","mutations","i","length","addedNodes","node","nodeType","tagName","push","addEventListener","beforeScriptExecuteListener","event","preventDefault","removeEventListener","parentElement","removeChild","observe","document","documentElement","childList","subtree","createdFrames","debugGate","localStorage","getItem","iframeObserver","includes","allFrames","querySelectorAll","count","forEach","console","log","readyState","body","createElementBackup","createElement","originalDescriptors","Object","getOwnPropertyDescriptor","HTMLScriptElement","prototype","args","toLowerCase","bind","scriptElt","defineProperties","get","call","this","set","value","typeValue","setAttribute","name","error","warn","URL_REPLACER_REGEXP","RegExp","scriptUrlsOrRegexes","filter","urlOrRegexp","toString","map","permissiveRegexp","replace","p","Boolean","ric","requestIdleCallback","cb","setTimeout","tags","array","callback","indexOffset","Promise","index","scriptNode","attributes","attr","key","startsWith","head","appendChild","splice","reduceRight","prev","current","resolve","unblockScripts","disconnect"],"mappings":"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"}